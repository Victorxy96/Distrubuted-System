import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Scanner;

/**
 * BabyVerify.java provides capabilities to verify very short messages. These
 * messages are 4 hex digits. BabyVerify has two private members: RSA e and n.
 * These are all very small java BigIntegers. BabyVerify is only used for
 * instructional purposes.
 * 
 *
 * For verification: the object is constructed with keys (e and n). The verify
 * method is called with two parameters - the string to be checked and the
 * evidence that this string was indeed manipulated by code with access to the
 * private key d. The message that is signed or verified is 4 hex digits. The
 * signature is represented by a base 10 integer.
 */

public class BabyVerify {

	private BigInteger e, n;

	/**
	 * For verifying, a SignOrVerify object may be constructed with a RSA's e and n.
	 * Only e and n are used for signature verification.
	 */
	public BabyVerify(BigInteger e, BigInteger n) {
		this.e = e;
		this.n = n;
	}

	/**
	 * Verifying proceeds as follows: 1) Decrypt the encryptedHash to compute a
	 * decryptedHash 2) Hash the messageToCheck using SHA-256 (be sure to handle the
	 * extra byte as described in the signing method.) 3) If this new hash is equal
	 * to the decryptedHash, return true else false.
	 * 
	 * @param messageToCheck   a normal string (4 hex digits) that needs to be
	 *                         verified.
	 * @param encryptedHashStr integer string - possible evidence attesting to its
	 *                         origin.
	 * @return true or false depending on whether the verification was a success
	 * @throws Exception
	 */
	public boolean verify(String messageToCheck, String encryptedHashStr) throws Exception {

		// Take the encrypted string and make it a big integer
		BigInteger encryptedHash = new BigInteger(encryptedHashStr);
		// Decrypt it
		BigInteger decryptedHash = encryptedHash.modPow(e, n);

		// Get the bytes from messageToCheck
		byte[] bytesOfMessageToCheck = messageToCheck.getBytes("UTF-8");

		// compute the digest of the message with SHA-256
		MessageDigest md = MessageDigest.getInstance("SHA-256");

		byte[] messageToCheckDigest = md.digest(bytesOfMessageToCheck);

		// messageToCheckDigest is a full SHA-256 digest
		// take two bytes from SHA-256 and add a zero byte
		byte[] extraByte = new byte[3];
		extraByte[0] = 0;
		extraByte[1] = messageToCheckDigest[0];
		extraByte[2] = messageToCheckDigest[1];

		// Make it a big int
		BigInteger bigIntegerToCheck = new BigInteger(extraByte);

		// inform the client on how the two compare
		if (bigIntegerToCheck.compareTo(decryptedHash) == 0) {

			return true;
		} else {
			return false;
		}
	}

	public static void main(String args[]) throws Exception {

		// Test driver for BabyVerify

		// BabyVerify may use some really small keys
		// The keys were generated by the RSA algorithm
		// p and q were 20 bits each
		BigInteger e = new BigInteger("65537");

		BigInteger n = new BigInteger("9013594933187057813");

		BabyVerify verifySig = new BabyVerify(e, n);

		Scanner sc = new Scanner(System.in);

		// Check an existing signature

		System.out.println("Enter hash that was signed (4 hex digits)");
		System.out.println("All data will be converted to lower case");
		String data = sc.nextLine();
		if (data.length() != 4) {
			System.out.println("Invalid input");
			System.exit(0);
		}
		data = data.toLowerCase();
		System.out.println("Enter an integer representing the signature");
		String sig = sc.nextLine();
		if (verifySig.verify(data, sig)) {
			System.out.println("Valid signature");
		} else {
			System.out.println("invalid signature");
		}

	}

	// from Stack overflow
	public static byte[] hexStringToByteArray(String s) {
		int len = s.length();
		byte[] data = new byte[len / 2];
		for (int i = 0; i < len; i += 2) {
			data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i + 1), 16));
		}
		return data;
	}
}
