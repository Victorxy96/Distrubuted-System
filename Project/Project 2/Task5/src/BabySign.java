
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Scanner;

/**
 * BabySign.java provides capabilities to sign very short messages. These
 * messages are 4 hex digits. BabySign has three private members: RSA e,d and n.
 * These are all very small java BigIntegers. BabySign is only used for
 * instructional purposes.
 * 
 * For signing: the BabySign object is constructed with RSA keys (e,d,n). These
 * keys are not created here but are passed in by the caller. Then, a caller can
 * sign a message - the string returned by the sign method is evidence that the
 * signer has the associated private key. After a message is signed, the message
 * and the string may be transmitted or stored. The signature is represented by
 * a base 10 integer.
 */

public class BabySign {

	private BigInteger e, d, n;

	/**
	 * A BabySign object may be constructed with RSA's e, d, and n. The holder of
	 * the private key (the signer) would call this constructor. Only d and n are
	 * used for signing.
	 */
	public BabySign(BigInteger e, BigInteger d, BigInteger n) {
		this.e = e;
		this.d = d;
		this.n = n;
	}

	/**
	 * Signing proceeds as follows: 1) Get the bytes from the string to be signed.
	 * 2) Compute a SHA-1 digest of these bytes. 3) Copy these bytes into a byte
	 * array that is one byte longer than needed. The resulting byte array has its
	 * extra byte set to zero. This is because RSA works only on positive numbers.
	 * The most significant byte (in the new byte array) is the 0'th byte. It must
	 * be set to zero. 4) Create a BigInteger from the byte array. 5) Encrypt the
	 * BigInteger with RSA d and n. 6) Return to the caller a String representation
	 * of this BigInteger.
	 * 
	 * @param message a sting to be signed
	 * @return a string representing a big integer - the encrypted hash.
	 * @throws Exception
	 */
	public String sign(String message) throws Exception {

		// compute the digest with SHA-256
		byte[] bytesOfMessage = message.getBytes("UTF-8");
		MessageDigest md = MessageDigest.getInstance("SHA-256");
		byte[] bigDigest = md.digest(bytesOfMessage);

		// we only want two bytes of the hash for BabySign
		// we add a 0 byte as the most significant byte to keep
		// the value to be signed non-negative.
		byte[] messageDigest = new byte[3];
		messageDigest[0] = 0; // most significant set to 0
		messageDigest[1] = bigDigest[0]; // take a byte from SHA-256
		messageDigest[2] = bigDigest[1]; // take a byte from SHA-256

		// The message digest now has three bytes. Two from SHA-256
		// and one is 0.

		// From the digest, create a BigInteger
		BigInteger m = new BigInteger(messageDigest);

		// encrypt the digest with the private key
		BigInteger c = m.modPow(d, n);

		// return this as a big integer string
		return c.toString();
	}

	public static void main(String args[]) throws Exception {

		// Test driver for BabySign

		// BabySign may use some really small keys
		// The keys were generated by the RSA algorithm
		// p and q were 20 bits each
		BigInteger e = new BigInteger("65537");
		BigInteger d = new BigInteger("5420920152787448033");
		BigInteger n = new BigInteger("9013594933187057813");

		BabySign sov = new BabySign(e, d, n);

		Scanner sc = new Scanner(System.in);

		// Get some data to sign
		System.out.println("Enter data to be signed (at most 4 hex digits)");
		System.out.println("All data will be converted to lower case");
		String inStr = sc.nextLine();
		if (inStr.length() != 4) {
			System.out.println("Error in input " + inStr);
			return;
		}
		inStr = inStr.toLowerCase();

		// add a 0 byte to keep it positive
		byte b[] = hexStringToByteArray("00" + inStr);

		// This messsage is the unsigned integer value of the
		// two bytes entered
		BigInteger m = new BigInteger(b);

		String signedVal = sov.sign(inStr);
		System.out.println("Signed Value");
		System.out.println(signedVal);

	}

	// From Stack overflow
	public static byte[] hexStringToByteArray(String s) {
		int len = s.length();
		byte[] data = new byte[len / 2];
		for (int i = 0; i < len; i += 2) {
			data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i + 1), 16));
		}
		return data;
	}
}
