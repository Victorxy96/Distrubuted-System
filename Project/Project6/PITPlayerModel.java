package pit;

import java.io.Serializable;
import java.util.*;
import javax.jms.*;
import javax.jms.Queue;
import javax.naming.*;

import static java.util.Map.*;

/*
 * This is the ONLY file that you are to edit.  It is the model of play for
 * every PITplayer.  Each PITplayer instantiates this model and uses it to
 * process the messages it receives.
 */
public class PITPlayerModel {

    // Each PITplayer has a unique myPlayerNumber.  It is set in the PITPlayer constructor.
    private final int myPlayerNumber;
    // Cards is this player's set of cards.
    private final ArrayList cards = new ArrayList();
    // numTrades counts trades.
    private int numTrades = 0;
    // maxTrades is the maximum number of trades, after which trading is stopped.
    private final int maxTrades = 20000;
    // numPlayers are the number of Players trading.  This comes with a NewHand from the PITsnapshot servlet
    private int numPlayers = 0;
    // halting indicates that the system is being reset, so ignore trades until a new had received
    private boolean halting = false;

    /* The snapshot servlet (PITsnapshot) is expecting to be passed an ObjectMessage
     * where the object is a HashMap. Therefore this definition of HashMap is
     * provided although it is not currently used (it is for you to use).
     * PITsnapshot is expecting a set of attribute/value pairs. These include the player
     * number, as in state.put("Player",myPlayerNumber), and each commodity string
     * and the number of that commodity in the snapshot.
     * Also included below is a utility method that will convert a HashMap into a string
     * which is useful for printing diagnostic messages to the console.
     */
    private HashMap<String, Integer> state = new HashMap<String, Integer>();

    // usage like boolean array to record whether we have received marker from all channels
    private HashSet<Integer> channelsFlags = new HashSet<Integer>();

    // a flag to record whether I am taking part in this snapshot or not
    private boolean hasTakePartSnapshot = false;

    // PITPlayerModel constructor saves what number player this object represents.
    PITPlayerModel(int myNumber) {
        myPlayerNumber = myNumber;
    }

    /**
     * Deal with each message according to its type
     * @param message incoming message
     */
    public void onMessage(Message message) {
        try {
            if (message instanceof ObjectMessage) {
                Object o = ((ObjectMessage) message).getObject();

                /*
                 * There are 6 types of messages:  Reset, NewHand, TenderOffer,
                 * AcceptOffer, RejectOffer, and Marker
                 */

                // Reset the Player. This message is generated by the PITsnapshot servlet
                if (o instanceof Reset) {
                    doReset((Reset) o);

                    // NewHand received from PITsnapshot
                } else if (o instanceof NewHand) {
                    // Add the new hand into cards
                    doNewHand((NewHand) o);

                    // Receive an offer from another Player
                } else if (o instanceof TenderOffer) {
                    doReceiveTenderOffer((TenderOffer) o);

                    // Another Player accepted our offer
                } else if (o instanceof AcceptOffer) {
                    doReceiveAcceptOffer((AcceptOffer) o);

                    // Another Player rejected our offer
                } else if (o instanceof RejectOffer) {
                    doReceiveRejectOffer((RejectOffer) o);

                    // Receives a Marker message
                } else if (o instanceof Marker) {
                    doMarker((Marker) o);

                } else {
                    System.out.println("PITplayer" + myPlayerNumber + " received unknown Message type");
                    // just ignore it
                }
            }
        } catch (Exception e) {
            System.out.println("Exception thrown in PITplayer" + myPlayerNumber + ": " + e);
        }
    }

    private void doReset(Reset reset) throws Exception {
        // Resetting is done by two messages, first to halt, then to clear
        if (reset.action == Reset.HALT) {
            System.out.println("PITplayer" + myPlayerNumber + " received Reset HALT");
            halting = true;
            // Reply to the PITsnapshot servlet acknowledging the Reset HALT
            sendToQueue("openejb:Resource/PITmonitor", reset);
        } else { // action == Reset.CLEAR
            System.out.println("PITplayer" + myPlayerNumber + " received Reset RESET");
            // Drop all cards in hand
            cards.clear();
            numTrades = 0;
            numPlayers = 0;
            halting = false;
            // Reply to the PITsnapshot servlet acknowledging the Reset
            sendToQueue("openejb:Resource/PITmonitor", reset);
        }
    }

    private void doNewHand(NewHand hand) throws Exception {

        // Add a new hand of cards.
        // It is actually possible that an offer from another Player has been
        // accepted already, beating the NewHand
        cards.addAll((hand).newHand);
        numPlayers = (hand).numPlayers;
        System.out.println("PITplayer" + myPlayerNumber + " new hand: " + toString(cards));

        // Offer a card to another Player
        doTenderOffer();
    }

    private void doReceiveTenderOffer(TenderOffer trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }

        System.out.println("PITplayer" + myPlayerNumber + " received offer of: " + trade.tradeCard + " from player: " + trade.sourcePlayer);

        // When receiving an offer, decide whether to Accept or Reject it
        if (acceptOrNot(trade)) {
        // if (Math.random() < 0.8) {
            // Accept the trade 80% of the time

            // Add the Offer to my hand of cards
            cards.add(trade.tradeCard);

            // Pay with one of my cards
            doReplyAccept(trade.sourcePlayer);

        } else {
            /* Otherwise reject the offer and send back the card */
            doReplyReject(trade);
        }

        // get the channel where the message from
        int c = trade.sourcePlayer;
        // get the type of card of the offer
        String type = trade.tradeCard;
        // update the snapshot
        updateState(c, type);
    }

    /**
     * The other player can accept, and they pay with a commodity of their own.
     * @param sendTo the counterpart of the trade
     * @throws Exception
     */
    private void doReplyAccept(int sendTo) throws Exception {

        // if hit maxTrades limit, then stop sending trades
        if (maxTrades(maxTrades)) {
            return;
        }

        // In payment for the card I just accepted, send back one of my cards.
        AcceptOffer newTrade = new AcceptOffer();

        String type = removeNonMostCard();

        if (type != null) {
            newTrade.tradeCard = type;
        } else {
            // remove the first card in hand as the payment
            newTrade.tradeCard = (String) cards.remove(0);
        }

        // set the sender of the offer as my number
        newTrade.sourcePlayer = myPlayerNumber;

        //Send the card to the other player
        System.out.println("PITplayer" + myPlayerNumber + " accepting offer and paying with: " + newTrade.tradeCard + " to player: " + sendTo);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));

        // Other players can communicate with the player by sending a message to its Queue.
        String sendToJNDI = "openejb:Resource/PITplayer" + sendTo;
        sendToQueue(sendToJNDI, newTrade);
    }

    // Reply rejecting an offer that was received. Send back their card.
    private void doReplyReject(TenderOffer trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }

        System.out.println("PITplayer" + myPlayerNumber + " rejecting offer of: " + trade.tradeCard + " from player: " + trade.sourcePlayer);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));

        // if hit maxTrades limit, then stop sending trades
        if (maxTrades(maxTrades)) {
            return;
        }

        // Send back their card that I am rejecting
        RejectOffer newTrade = new RejectOffer();
        newTrade.tradeCard = trade.tradeCard;
        newTrade.sourcePlayer = myPlayerNumber;

        // Send the card to the other player
        String sendToJNDI = "openejb:Resource/PITplayer" + trade.sourcePlayer;
        sendToQueue(sendToJNDI, newTrade);

    }

    // Handle receiving a message that a previous offer has been accepted.
    // They would have replied with another card as payment.
    private void doReceiveAcceptOffer(AcceptOffer trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }
        // Having received a AcceptOffer from another Player, add it to my hand of cards
        cards.add(trade.tradeCard);

        // get the channel where the message from
        int c = trade.sourcePlayer;
        // get the type of card of the offer
        String type = trade.tradeCard;
        // update the snapshot
        updateState(c, type);

        System.out.println("PITplayer" + myPlayerNumber + " received: " + trade.tradeCard + " as payment from player: " + trade.sourcePlayer);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));

        // Make another offer to a random player
        doTenderOffer();
    }

    // Handle receiving a reject message regarding a prior offer I made
    private void doReceiveRejectOffer(RejectOffer trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }
        // Because the offer was rejected, and returned, add it back into my cards
        cards.add(trade.tradeCard);

        // get the channel where the message from
        int c = trade.sourcePlayer;
        // get the type of card of the offer
        String type = trade.tradeCard;
        // update the snapshot
        updateState(c, type);

        System.out.println("PITplayer" + myPlayerNumber + " received rejected offer of: " + trade.tradeCard + " from player: " + trade.sourcePlayer);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));

        // Make another offer to a random player
        doTenderOffer();
    }

    // Make an offer to a random player
    private void doTenderOffer() throws Exception {

        // if hit maxTrades limit, then stop sending trades
        if (maxTrades(maxTrades)) {
            return;
        }

        /*
         * If numPlayers == 0, while we have received a TenderOffer, we have not
         * received our NewHand yet, so we don't know how many players there
         * are.  Therefore, don't send out a TenderOffer at this time.
         *
         */
        if (numPlayers == 0) {
            return;
        }

        // Create a new offer from my set of cards, and send to another player
        TenderOffer newTrade = new TenderOffer();

        String type = removeNonMostCard();

        // Randomly remove the first card for trading
        if (type != null) {
            newTrade.tradeCard = type;
        } else {
            // remove the first card in hand as the payment
            newTrade.tradeCard = (String) cards.remove(0);
        }

        // set the offer sender as me
        newTrade.sourcePlayer = myPlayerNumber;

        // Find a random player to trade to (not including myself)
        int sendTo = myPlayerNumber;

        // A player initiates a trade by making an offer to
        // another randomly chosen player.
        while (sendTo == myPlayerNumber) {
            sendTo = Math.round((float) Math.random() * (numPlayers - 1));
        }

        // Send the card to the other player
        System.out.println("PITplayer" + myPlayerNumber + " offered: " + newTrade.tradeCard + " to player: " + sendTo);

        // Other players can communicate with the player by sending a message to its Queue.
        String sendToJNDI = "openejb:Resource/PITplayer" + sendTo;
        sendToQueue(sendToJNDI, newTrade);

    }

    /**
     * Implement Chandy Lamport Snapshot Algorithm to check the state of players and commodities
     * when receiving the marker message.
     * @param marker the marker message that suggests that we need to count the commodities
     * @throws Exception
     */
    private void doMarker(Marker marker) throws Exception {
        // source is the Player number from which the Marker is sent
        int c = marker.source;

        // When I receive a marker on channel c:
        if (c != -1) {
            channelsFlags.add(c);
        }

        // I am not yet taking part in this snapshot
        if (!hasTakePartSnapshot) {
            // Record my state now
            for (Object card : cards) {
                // count # of each commodity in hand only
                int count = state.get(card) == null ? 0 : state.get(card);
                state.put((String) card, count + 1);
            }

            /*
             * Do Marker sending rule:
             * For (each outgoing channel c) {
             *      Send one marker message over c
             * }
             */
            for (int i = 0; i < numPlayers; i++) {
                // send markers to other channels except me
                if (i != myPlayerNumber) {
                    // send markers message to others
                    String sendToJNDI = "openejb:Resource/PITplayer" + i;
                    sendToQueue(sendToJNDI, new Marker(myPlayerNumber));
                }
            }
            hasTakePartSnapshot = true;
        }

        // this is last channel to receive marker on
        if (channelsFlags.size() == numPlayers - 1) {
            state.put("Player", myPlayerNumber);

            // The PITsnapshot Queue is used for responses from the Players to this serverlet
            String sendToJNDI = "openejb:Resource/PITsnapshot";

            // send records to Monitor process
            sendToQueue(sendToJNDI, state);

            // reset the all types of snapshot flags to initial states
            state = new HashMap<String, Integer>();
            hasTakePartSnapshot = false;
            channelsFlags = new HashSet<Integer>();
        }
    }

    // Create a string of hand size and all cards
    private String toString(ArrayList hand) {

        String cardsString = "size: " + hand.size() + " ";
        for (int i = 0; i < hand.size(); i++) {
            cardsString += hand.get(i) + " ";
        }
        return cardsString;
    }

    // Create a printable version of the "state".
    private String toString(HashMap<String, Integer> state) {
        String stateString = "";
        for (Iterator it = state.entrySet().iterator(); it.hasNext();) {
            Entry entry = (Entry) it.next();
            String commodity = (String) entry.getKey();
            int number = ((Integer) entry.getValue()).intValue();
            stateString += "{" + commodity + ":" + number + "} ";
        }
        return stateString;
    }

    // Send an object to a Queue, given its JNDI name
    private void sendToQueue(String queueJNDI, Serializable message) throws Exception {
        // Gather necessary JMS resources
        Context ctxt = new InitialContext();
        Connection con = ((ConnectionFactory) ctxt.lookup("openejb:Resource/myConnectionFactory")).createConnection();
        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
        Queue q = (Queue) ctxt.lookup(queueJNDI);
        MessageProducer writer = session.createProducer(q);
        ObjectMessage msg = session.createObjectMessage(message);
        // Send the object to the Queue
        writer.send(msg);
        session.close();
        con.close();
        ctxt.close();
    }

    // Stop trading when the max number of Trades is reached
    private boolean maxTrades(int max) {
        if ((numTrades % 100) == 0) {
            System.out.println("PITplayer" + myPlayerNumber + " numTrades: " + numTrades);
        }
        return (numTrades++ < max) ? false : true;
    }

    /**
     * Update the state HashMap
     * @param channel the incoming channel number
     * @param type the type of the card
     */
    private void updateState(int channel, String type) {

        // this marker is coming in from a new channel c
        // Snapshot have started
        if (!channelsFlags.contains(channel) && hasTakePartSnapshot) {
            // Begin keeping track of state all other incoming channels (except c):
            int count = state.get(type) == null ? 0 : state.get(type);
            // (I.e. count commodities arriving via each channel.)
            state.put(type, count + 1);
        }
    }

    /**
     * Whether I accept the offer or not
     * @param trade trade message I received
     * @return true if I accept
     * @throws Exception
     */
    private boolean acceptOrNot(TenderOffer trade) throws Exception {
        // the type of card that we want to become monopoly
        String mostType = mostCardIHave();

        // Behavior: Only accept offer whose type is
        // the same as the type of card
        // which has the highest frequency in hand now
        if (trade.tradeCard.equals(mostType)) {
            return true;
        }

        // otherwise reject the offer
        return false;
    }

    /**
     * Get the most common card that I hold in hand
     * @return the type of the largest number of card I have
     */
    private String mostCardIHave() {
        String mostType = null;
        int maxCount = Integer.MIN_VALUE;

        if (hasTakePartSnapshot) {

            // find the mode of the frequencies
            for (String type : state.keySet()) {
                // number of card of one type
                int count = state.get(type);
                // update the mode number if we find a higher count
                if (count >= maxCount) {
                    maxCount = count;
                    mostType = type;
                }
            }
        } else {
            // if we have not received the marker message the state hashMap is empty
            HashMap<String, Integer> freq = new HashMap<String, Integer>();

            // set up a new hashMap to count the frequency of each card
            for (Object o: cards) {
                String card = (String) o;
                int count = freq.get(card) == null ? 0 : freq.get(card);
                freq.put(card, count + 1);
            }

            // find the mode of the frequencies
            for (String type : freq.keySet()) {
                // number of card of one type
                int count = freq.get(type);
                // update the mode number if we find a higher count
                if (count >= maxCount) {
                    maxCount = count;
                    mostType = type;
                }
            }
        }
        return mostType;
    }

    private String removeNonMostCard() {
        String type = null;
        for (int i = 0; i < cards.size(); i++) {
            String community = (String) cards.get(i);
            if (!community.equals(mostCardIHave())) {
                type = (String) cards.remove(i);
                break;
            }
        }
        return type;
    }
}
